(()=>{"use strict";class r{constructor(r=10){this.boardSize=r,this.board=this.initBoard(this.boardSize),this.placedShips=[],this.missedHits=[]}initBoard=r=>{const t=new Array(r);for(let i=0;i<r;i++)t[i]=new Array(r).fill(null);return t};placeShip=(r,t,i,o="vertical")=>{this.canPlaceShip(r,t,i,o);for(let a=0;a<r.shipSize;a++){let h=t+("vertical"===o?a:0),e=i+("horizontal"===o?a:0);this.board[h][e]=r}return this.placedShips.push(r),!0};randomPlaceShip=r=>{for(let t=0;t<100;t++){let t,i,o=Math.random()>.5?"horizontal":"vertical";if("vertical"===o?(t=Math.floor(Math.random()*(this.boardSize-r.shipSize+1)),i=Math.floor(Math.random()*this.boardSize)):(t=Math.floor(Math.random()*this.boardSize),i=Math.floor(Math.random()*(this.boardSize-r.shipSize+1))),this.canPlaceShip(r,t,i,o))return this.placeShip(r,t,i,o),!0}return!1};canPlaceShip=(r,t,i,o)=>{if(t>=this.boardSize||i>=this.boardSize)throw new Error("Starting position is out of bounds");if("vertical"===o&&t+r.shipSize>this.boardSize||"horizontal"===o&&i+r.shipSize>this.boardSize)throw new Error("Ship goes out of bounds");for(let a=0;a<r.shipSize;a++){let r=t+("vertical"===o?a:0),h=i+("horizontal"===o?a:0);if(null!==this.board[r][h])throw new Error("Ship overlap")}return!0};receiveAttack=(r,t)=>{if(r>this.boardSize&&t>this.boardSize)throw new Error("Attack goes out of bounds");if(1===this.board[r][t])throw new Error("Already used attack");return null!==this.board[r][t]?(this.board[r][t].hit(),this.board[r][t]=1,!0):(this.board[r][t]=1,!1)};isSunk=()=>{let r=!0;return this.placedShips.forEach((t=>{!1===t.isSunk()&&(r=!1)})),r}}class t{constructor(t){this.name=t,this.board=new r(10),this.isHuman=!0}placeShip=(r,t,i,o)=>{try{this.board.placeShip(r,t,i,o)}catch(r){throw r}};randomPlaceShip=r=>{r.forEach((r=>{this.board.randomPlaceShip(r)}))};attackEnemy=(r,t,i)=>{try{return i.receiveAttack(r,t)}catch(r){throw r}};hasLost=()=>this.board.isSunk()}new t("john"),new t("trevor"),console.log()})();